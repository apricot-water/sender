<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Familien Chat</title>
<style>
    /* === VARIABLES & THEME === */
    :root {
        --bg-app: #f2f2f7; --bg-card: #ffffff; --text-main: #000000; --text-sub: #8e8e93;
        --input-bg: #e5e5ea; --accent: #007aff; --danger: #ff3b30; --sidebar-bg: #ffffff;
    }
    body.dark {
        --bg-app: #000000; --bg-card: #1c1c1e; --text-main: #ffffff; --text-sub: #98989f;
        --input-bg: #2c2c2e; --accent: #0a84ff; --sidebar-bg: #1c1c1e;
    }
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    body { margin: 0; padding: 0; font-family: -apple-system, sans-serif; background: var(--bg-app); color: var(--text-main); height: 100dvh; width: 100vw; overflow: hidden; display: flex; justify-content: center; }

    /* === LAYOUT === */
    .app-wrapper { width: 100%; max-width: 600px; background: var(--bg-card); display: flex; flex-direction: column; height: 100%; position: relative; box-shadow: 0 0 20px rgba(0,0,0,0.1); overflow: hidden; }
    
    /* === HEADER === */
    .app-header { flex: 0 0 60px; display: flex; align-items: center; justify-content: space-between; padding: 0 15px; border-bottom: 1px solid var(--input-bg); z-index: 20; background: var(--bg-card); }
    .header-title { font-weight: 700; font-size: 17px; }
    .btn-icon { background: none; border: none; cursor: pointer; color: var(--accent); padding: 8px; display: flex; align-items: center; justify-content: center; }

    /* === SIDEBAR (MENU) === */
    .sidebar-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 50; opacity: 0; pointer-events: none; transition: opacity 0.3s; }
    .sidebar-overlay.open { opacity: 1; pointer-events: auto; }
    
    .sidebar { position: absolute; top: 0; left: 0; bottom: 0; width: 280px; background: var(--sidebar-bg); z-index: 51; transform: translateX(-100%); transition: transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1); padding-top: 60px; display: flex; flex-direction: column; }
    .sidebar.open { transform: translateX(0); }
    
    .menu-item { padding: 15px 20px; font-size: 18px; font-weight: 500; border-bottom: 1px solid var(--input-bg); cursor: pointer; display: flex; align-items: center; gap: 15px; }
    .menu-item:active { background: var(--input-bg); }
    .menu-item.active { color: var(--accent); background: rgba(0,122,255,0.1); }
    
    /* === TABS (CONTENT) === */
    .tab-content { display: none; flex: 1; flex-direction: column; overflow: hidden; height: 100%; }
    .tab-content.active { display: flex; }

    /* === SENDER STYLES === */
    .scroll-area { flex: 1; overflow-y: auto; padding: 20px; display: flex; flex-direction: column; gap: 20px; }
    input, textarea { width: 100%; background: var(--input-bg); border: none; color: var(--text-main); padding: 16px; border-radius: 12px; font-size: 17px; font-family: inherit; resize: none; }
    input:focus, textarea:focus { outline: none; box-shadow: 0 0 0 2px var(--accent); }
    .label-small { font-size: 13px; color: var(--text-sub); margin-left: 12px; margin-bottom: 6px; font-weight: 500; text-transform: uppercase; }
    .media-upload { background: var(--input-bg); border-radius: 12px; padding: 20px; text-align: center; cursor: pointer; border: 2px dashed rgba(128,128,128,0.3); }
    .media-preview-img { width: 100%; height: 200px; object-fit: cover; border-radius: 8px; display: none; margin-top: 10px; }
    .bottom-bar { padding: 20px; border-top: 1px solid var(--input-bg); padding-bottom: calc(20px + env(safe-area-inset-bottom)); }
    .btn-primary { width: 100%; background: linear-gradient(135deg, #007aff, #005ecb); color: white; font-size: 17px; font-weight: 600; padding: 14px; border: none; border-radius: 12px; cursor: pointer; }
    
    /* === VIEWER STYLES (Mini Version of empf√§nger.html) === */
    .viewer-container { flex: 1; background: #000; display: flex; flex-direction: column; align-items: center; justify-content: center; position: relative; color: white; text-align: center; padding: 10px; }
    .viewer-img { max-width: 100%; max-height: 50vh; object-fit: contain; border-radius: 10px; margin-bottom: 15px; display: none; }
    .viewer-text { font-size: 24px; font-weight: bold; line-height: 1.3; max-height: 40vh; overflow-y: auto; width: 100%; }
    .viewer-meta { position: absolute; top: 10px; width: 100%; text-align: center; color: #666; font-size: 12px; }
    .viewer-nav { position: absolute; top: 50%; width: 100%; display: flex; justify-content: space-between; padding: 0 10px; pointer-events: none; }
    .nav-btn { pointer-events: auto; background: rgba(255,255,255,0.2); border: none; color: white; font-size: 24px; width: 50px; height: 50px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; }
    .nav-btn:active { background: rgba(255,255,255,0.4); }

    /* === SETTINGS MODAL === */
    #settingsModal { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: var(--bg-card); z-index: 100; transform: translateY(100%); transition: transform 0.3s; display: flex; flex-direction: column; }
    #settingsModal.open { transform: translateY(0); }
    .setting-row { padding: 15px; border-bottom: 1px solid var(--input-bg); }
    
    #toast { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.9); background: rgba(0,0,0,0.85); color: white; padding: 15px 25px; border-radius: 30px; opacity: 0; pointer-events: none; transition: 0.2s; z-index: 200; }
    #toast.show { opacity: 1; transform: translate(-50%, -50%) scale(1); }
/* === PROGRESS OVERLAY === */
    #progressOverlay {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.4); backdrop-filter: blur(5px);
        z-index: 200;
        display: flex; align-items: center; justify-content: center;
        opacity: 0; pointer-events: none; transition: opacity 0.3s;
    }
    #progressOverlay.open { opacity: 1; pointer-events: auto; }

    .progress-card {
        background: var(--bg-card); width: 80%; max-width: 300px;
        padding: 25px; border-radius: 20px; text-align: center;
        box-shadow: 0 10px 40px rgba(0,0,0,0.2);
    }
    
    .progress-title { font-size: 18px; font-weight: 600; margin-bottom: 15px; }
    .progress-status { font-size: 13px; color: var(--text-sub); margin-bottom: 15px; min-height: 1.2em;}

    .progress-track {
        background: var(--input-bg); height: 8px; border-radius: 4px; overflow: hidden; position: relative;
    }
    .progress-bar {
        background: var(--accent); height: 100%; width: 0%;
        transition: width 0.2s; border-radius: 4px;
    }

</style>
</head>
<body>

<div class="app-wrapper">
    <!-- PROGRESS OVERLAY -->
    <div id="progressOverlay">
        <div class="progress-card">
            <div class="progress-title">Sende Nachricht...</div>
            <div id="progressStatus" class="progress-status">Vorbereitung...</div>
            <div class="progress-track">
                <div id="progressBar" class="progress-bar"></div>
            </div>
            <div id="progressPercent" style="font-size:12px; margin-top:5px; color:var(--text-sub)">0%</div>
        </div>
    </div>
    
    <!-- HEADER -->
    <header class="app-header">
        <button class="btn-icon" onclick="toggleSidebar(true)">
            <!-- Hamburger Icon -->
            <svg width="24" height="24" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" stroke-linecap="round"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg>
        </button>
        <div class="header-title" id="pageTitle">Nachricht schreiben</div>
        <button class="btn-icon" onclick="toggleSettings(true)">‚öôÔ∏è</button>
    </header>

    <!-- SIDEBAR -->
    <div class="sidebar-overlay" onclick="toggleSidebar(false)"></div>
    <div class="sidebar">
        <div style="padding: 0 20px 20px 20px; font-weight:bold; font-size:20px; color:var(--text-sub)">Men√º</div>
        <div class="menu-item active" onclick="switchTab('send')">‚úçÔ∏è Schreiben</div>
        <div class="menu-item" onclick="switchTab('view')">üëÄ Omas Sicht</div>
        <div style="flex:1"></div>
        <div class="menu-item" style="font-size:14px; color:var(--text-sub)" onclick="toggleDarkMode()">üåô Dark Mode umschalten</div>
    </div>

    <!-- TAB: SENDER -->
    <div id="tab-send" class="tab-content active">
        <div class="scroll-area">
            <div>
                <div class="label-small">Dein Name</div>
                <input id="senderName" placeholder="Name">
            </div>
            <div style="flex:1; display:flex; flex-direction:column;">
                <div class="label-small">Nachricht</div>
                <textarea id="msgText" placeholder="Hallo Oma..." style="flex:1; min-height:150px;"></textarea>
            </div>
            <div class="media-upload" onclick="document.getElementById('fileInput').click()">
                <div style="font-size:24px; opacity:0.5">üì∑</div>
                <div id="mediaText" style="font-weight:600; color:var(--accent); margin-top:5px">Foto anh√§ngen</div>
                <img id="imagePreview" class="media-preview-img">
                <input type="file" id="fileInput" accept="image/*" style="display:none" onchange="previewFile()">
            </div>
        </div>
        <div class="bottom-bar">
            <button id="btnSend" class="btn-primary" onclick="send()">Senden üöÄ</button>
        </div>
    </div>

    <!-- TAB: VIEWER -->
    <div id="tab-view" class="tab-content">
        <div class="viewer-container">
            <div class="viewer-meta" id="viewerMeta">Lade Daten...</div>
            <img id="viewerImg" class="viewer-img">
            <div id="viewerText" class="viewer-text"></div>
            
            <div class="viewer-nav">
                <button class="nav-btn" onclick="viewerNext(-1)">‚ùÆ</button>
                <button class="nav-btn" onclick="viewerNext(1)">‚ùØ</button>
            </div>
        </div>
        <div style="padding:10px; text-align:center; font-size:11px; color:var(--text-sub); background:#000;">
            Vorschau (Aktualisiert alle 30m via GitHub)
        </div>
    </div>

    <!-- SETTINGS -->
    <div id="settingsModal">
        <header class="app-header">
            <div class="header-title">Einstellungen</div>
            <button class="btn-icon" onclick="saveConf()">Fertig</button>
        </header>
        <div class="scroll-area">
            <div class="label-small">Kanal Name (ntfy)</div>
            <input id="confTopic" placeholder="oma_geheim">
            <div class="label-small" style="margin-top:15px">Passwort</div>
            <input id="confPass" type="text" placeholder="Geheim">
            
            <hr style="border:0; border-top:1px solid var(--input-bg); margin: 20px 0;">
            <div class="label-small">GitHub User</div>
            <input id="confGhUser" placeholder="z.B. deinUser">
            <div class="label-small" style="margin-top:15px">GitHub Repo</div>
            <input id="confGhRepo" placeholder="z.B. oma-chat">
            <div class="label-small" style="margin-top:15px">GitHub Token</div>
            <input id="confGhToken" type="password" placeholder="github_pat_...">
            <div style="font-size:11px; color:var(--text-sub); margin-top:5px">Ben√∂tigt f√ºr den Verlauf ("Omas Sicht").</div>
        </div>
    </div>

    <div id="toast">Nachricht gesendet!</div>
</div>
<script>
    // --- 1. MAGIC LINK & CONFIG ---
    let conf = { t: '', p: '', gu: '', gr: '', gt: '' };

    (function initConfig() {
        try { Object.assign(conf, JSON.parse(localStorage.getItem('oma_conf_v2') || '{}')); } catch(e){}
        const hash = window.location.hash;
        if (hash.startsWith('#config=')) {
            try {
                const json = JSON.parse(atob(hash.substring(8)));
                Object.assign(conf, json);
                localStorage.setItem('oma_conf_v2', JSON.stringify(conf));
                history.replaceState(null, null, window.location.pathname);
                alert("Einstellungen importiert! üéâ");
            } catch(e) { alert("Link fehlerhaft."); }
        }
        document.getElementById('confTopic').value = conf.t || '';
        document.getElementById('confPass').value = conf.p || '';
        document.getElementById('confGhUser').value = conf.gu || '';
        document.getElementById('confGhRepo').value = conf.gr || '';
        document.getElementById('confGhToken').value = conf.gt || '';
        if (localStorage.getItem('darkmode') === 'true') document.body.classList.add('dark');
    })();

    function saveConf() {
        conf.t = document.getElementById('confTopic').value.trim();
        conf.p = document.getElementById('confPass').value.trim();
        conf.gu = document.getElementById('confGhUser').value.trim();
        conf.gr = document.getElementById('confGhRepo').value.trim();
        conf.gt = document.getElementById('confGhToken').value.trim();
        localStorage.setItem('oma_conf_v2', JSON.stringify(conf));
        toggleSettings(false);
        if(activeTab === 'view') { loadViewerData(); startLiveViewer(); }
    }

    // --- 2. UI NAVIGATION ---
    let activeTab = 'send';
    function toggleSidebar(open) {
        const s = document.querySelector('.sidebar');
        const o = document.querySelector('.sidebar-overlay');
        if(open) { s.classList.add('open'); o.classList.add('open'); }
        else { s.classList.remove('open'); o.classList.remove('open'); }
    }
    
    function toggleSettings(open) {
        document.getElementById('settingsModal').classList.toggle('open', open);
    }

   function switchTab(tab) {
        activeTab = tab;
        document.querySelectorAll('.tab-content').forEach(e => e.classList.remove('active'));
        document.getElementById('tab-' + tab).classList.add('active');
        document.querySelectorAll('.menu-item').forEach(e => e.classList.remove('active'));
        if(event && event.currentTarget) event.currentTarget.classList.add('active'); 
        
        toggleSidebar(false);
        
        if(tab === 'send') document.getElementById('pageTitle').innerText = "Nachricht schreiben";
        
        if(tab === 'view') {
            document.getElementById('pageTitle').innerText = "Omas Sicht (Live)";
            
            // FIX: Live-Verbindung resetten!
            // Damit zwingen wir ntfy, uns alle Nachrichten aus dem Cache (since=all)
            // noch einmal zu senden, damit wir auch die sehen, die wir gerade gesendet haben.
            if(eventSource) {
                eventSource.close();
                eventSource = null;
            }

            loadViewerData(); 
            startLiveViewer(); 
        }
    }
    
    function toggleDarkMode() {
        document.body.classList.toggle('dark');
        localStorage.setItem('darkmode', document.body.classList.contains('dark'));
    }

    function showToast(msg) {
        const t = document.getElementById('toast'); t.innerText = msg; t.classList.add('show');
        setTimeout(() => t.classList.remove('show'), 2000);
    }

    // --- 3. CRYPTO UTILS ---
    const enc = new TextEncoder(); const dec = new TextDecoder();

    async function getKey(p, s){ 
        const k=await window.crypto.subtle.importKey("raw",enc.encode(p),{name:"PBKDF2"},false,["deriveKey"]); 
        return window.crypto.subtle.deriveKey({name:"PBKDF2",salt:s,iterations:100000,hash:"SHA-256"},k,{name:"AES-GCM",length:256},true,["encrypt","decrypt"]); 
    }

    function concatBuffers(salt, iv, data) {
        const tmp = new Uint8Array(salt.byteLength + iv.byteLength + data.byteLength);
        tmp.set(new Uint8Array(salt), 0);
        tmp.set(new Uint8Array(iv), salt.byteLength);
        tmp.set(new Uint8Array(data), salt.byteLength + iv.byteLength);
        return tmp.buffer;
    }

    async function encryptText(txt, pass){ 
        const raw = enc.encode(txt);
        const buf = await encryptData(raw, pass);
        let binary = ''; const bytes = new Uint8Array(buf);
        for (let i = 0; i < bytes.byteLength; i++) binary += String.fromCharCode(bytes[i]);
        return btoa(binary);
    }

    async function encryptData(dataBuffer, pass) {
        const s = window.crypto.getRandomValues(new Uint8Array(16)); 
        const iv = window.crypto.getRandomValues(new Uint8Array(12)); 
        const k = await getKey(pass, s); 
        const e = await window.crypto.subtle.encrypt({name:"AES-GCM",iv:iv}, k, dataBuffer); 
        return concatBuffers(s, iv, e);
    }

    async function decryptData(buffer, pass) {
        try {
            const bytes = new Uint8Array(buffer);
            const s = bytes.slice(0,16);
            const iv = bytes.slice(16,28);
            const data = bytes.slice(28);
            const k = await getKey(pass, s);
            return await window.crypto.subtle.decrypt({name:"AES-GCM",iv:iv}, k, data);
        } catch(e) { console.error("Decrypt Fail", e); return null; }
    }
    
    async function decryptText(b64, pass) {
        try {
            const binStr = atob(b64);
            const buf = new Uint8Array(binStr.length);
            for(let i=0; i<binStr.length; i++) buf[i] = binStr.charCodeAt(i);
            const decBuf = await decryptData(buf.buffer, pass);
            return decBuf ? dec.decode(decBuf) : null;
        } catch(e) { return null; }
    }
    
    function base64ToBuffer(b64) {
        const bin = atob(b64);
        const len = bin.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) bytes[i] = bin.charCodeAt(i);
        return bytes.buffer;
    }

    // --- 4. SENDER LOGIC ---
    function compressImage(file) { 
        return new Promise((resolve, reject) => {
            const reader = new FileReader(); reader.readAsDataURL(file);
            reader.onload = (event) => {
                const img = new Image(); img.src = event.target.result;
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const MAX = 1200; 
                    let w=img.width, h=img.height; 
                    if(w>h){if(w>MAX){h*=MAX/w;w=MAX;}}else{if(h>MAX){w*=MAX/h;h=MAX;}} 
                    canvas.width=w; canvas.height=h; 
                    const ctx=canvas.getContext("2d"); ctx.drawImage(img,0,0,w,h);
                    canvas.toBlob((b)=>resolve(b),'image/jpeg',0.7);
                };
            };
        });
    }

    async function send() {
        if(!conf.t || !conf.p) return alert("Einstellungen pr√ºfen!");
        const name = document.getElementById('senderName').value || "Familie";
        const text = document.getElementById('msgText').value;
        const fileInput = document.getElementById('fileInput').files[0];
        
        if(!text && !fileInput) return showToast("Leer?");

        const overlay = document.getElementById('progressOverlay');
        const status = document.getElementById('progressStatus');
        const bar = document.getElementById('progressBar');
        const perc = document.getElementById('progressPercent');
        overlay.classList.add('open'); bar.style.width='0%'; perc.innerText='0%';

        try {
            const payload = JSON.stringify({ sender: name, text: text, timestamp: Date.now() });
            const encTitle = await encryptText(payload, conf.p);
            
            let dataToSend = encTitle; 
            
            if(fileInput) {
                status.innerText = "Komprimiere..."; bar.style.width='20%';
                const compressedBlob = await compressImage(fileInput);
                status.innerText = "Verschl√ºssele Bild..."; bar.style.width='40%';
                const fileBuf = await compressedBlob.arrayBuffer();
                const encFileBuf = await encryptData(fileBuf, conf.p);
                dataToSend = new Blob([encFileBuf]);
            }

            status.innerText = "Lade hoch...";
            await new Promise((resolve, reject) => {
                const xhr = new XMLHttpRequest();
                const url = `https://ntfy.sh/${conf.t}`;
                
                if (fileInput) {
                    xhr.open('PUT', url);
                    xhr.setRequestHeader('Title', encTitle);
                    xhr.setRequestHeader('Filename', 'secure.bin');
                } else {
                    xhr.open('POST', url);
                    xhr.setRequestHeader('Title', 'Message');
                }

                xhr.upload.onprogress = (e) => {
                    if (e.lengthComputable) {
                        const vp = 40 + ((e.loaded/e.total)*60);
                        bar.style.width = vp+'%'; perc.innerText = Math.round(vp)+'%';
                    }
                };
                xhr.onload = () => (xhr.status >= 200 && xhr.status < 300) ? resolve() : reject(xhr.status);
                xhr.onerror = () => reject("Network Error");
                xhr.send(dataToSend);
            });

            bar.style.width='100%'; status.innerText="Fertig!";
            setTimeout(() => {
                overlay.classList.remove('open'); showToast("Sicher gesendet! üîí");
                document.getElementById('msgText').value=""; document.getElementById('fileInput').value=""; 
                document.getElementById('imagePreview').style.display='none';
            }, 500);

        } catch(e) {
            alert("Fehler: " + e); overlay.classList.remove('open');
        }
    }

    function previewFile() {
        const f = document.getElementById('fileInput').files[0];
        const img = document.getElementById('imagePreview');
        if(f){ img.src = URL.createObjectURL(f); img.style.display='block'; document.getElementById('mediaText').innerText="√Ñndern"; }
        else { img.style.display='none'; document.getElementById('mediaText').innerText="Foto anh√§ngen"; }
    }

    // --- 5. VIEWER LOGIC ---
    let viewerMsgs = [];
    let viewerIdx = 0;
    let viewerHiddenSet = new Set();

   async function loadViewerData() {
        const m = document.getElementById('viewerMeta');
        if(!conf.gu || !conf.gr || !conf.gt) {
            m.innerText = "GitHub Daten fehlen."; return;
        }
        
        m.innerText = "Lade Verlauf...";
        viewerMsgs = [];
        viewerHiddenSet.clear(); 
        
        try {
            const url = `https://api.github.com/repos/${conf.gu}/${conf.gr}/contents/messages.json?t=${Date.now()}`;
            const header = { 'Authorization': `Bearer ${conf.gt}`, 'Accept': 'application/vnd.github.v3+json' };
            const resp = await fetch(url, { headers: header, cache: "no-store" });
            
            if(!resp.ok) throw new Error("GitHub Zugriff verweigert");
            
            const fileData = await resp.json();
            
            let rawB64 = fileData.content; 
            if (!rawB64 && fileData.sha) {
                const blobUrl = `https://api.github.com/repos/${conf.gu}/${conf.gr}/git/blobs/${fileData.sha}`;
                const blobResp = await fetch(blobUrl, { headers: header });
                if(blobResp.ok) {
                    const blobData = await blobResp.json();
                    rawB64 = blobData.content;
                }
            }
            
            if(!rawB64) { m.innerText = "Archiv leer."; return; }

            const cleanB64 = rawB64.replace(/\s/g, ''); 
            const rawData = JSON.parse(decodeURIComponent(escape(atob(cleanB64))));
            
            for(let item of rawData) {
                // Blacklist f√ºllen
                if(item.hidden) {
                    viewerHiddenSet.add(item.timestamp);
                    continue; 
                }
                if(!item.enc) continue;

                const jsonStr = await decryptText(item.enc, conf.p);
                if(jsonStr) {
                    try {
                        const c = JSON.parse(jsonStr);
                        let finalImg = null;

                        if (item.img) {
                             try {
                                const encBuf = base64ToBuffer(item.img);
                                const decBuf = await decryptData(encBuf, conf.p);
                                if(decBuf) {
                                    const blob = new Blob([decBuf], {type: 'image/jpeg'});
                                    finalImg = URL.createObjectURL(blob);
                                }
                             } catch(err) { console.error("Img Decrypt Error", err); }
                        }

                        viewerMsgs.push({
                            ts: item.timestamp,
                            sender: c.sender || '?',
                            text: c.text || '',
                            img: finalImg, 
                            enc: item.enc 
                        });
                    } catch(e){}
                }
            }
            
            // --- CLEANUP (WICHTIG) ---
            // Wir filtern jetzt nochmal alles raus, was vielleicht durch den Live-Stream
            // reingekommen ist, w√§hrend wir das Archiv geladen haben.
            viewerMsgs = viewerMsgs.filter(m => !viewerHiddenSet.has(m.ts));
            // -------------------------
            
            viewerMsgs.sort((a,b) => a.ts - b.ts);
            
            if(viewerMsgs.length > 0) {
                viewerIdx = viewerMsgs.length - 1; 
                updateViewerUI();
            } else {
                if(document.getElementById('viewerMeta').innerText.includes("Lade")) {
                     document.getElementById('viewerMeta').innerText = "Archiv leer (Warte auf Live...)";
                }
                document.getElementById('viewerText').innerText = "Keine Nachrichten im Archiv.";
            }
            
        } catch(e) {
            m.innerText = "Ladefehler";
            document.getElementById('viewerText').innerText = e.message;
        }
    }

// --- LIVE VIEWER ---
    let eventSource = null;
    function startLiveViewer() {
        if(eventSource) return;
        if(!conf.t) return;

        console.log("Starte Live-Viewer...");
        eventSource = new EventSource(`https://ntfy.sh/${conf.t}/sse?since=all`);
        
        eventSource.onmessage = async (e) => {
            const data = JSON.parse(e.data);
            if(data.event === 'message') {
                
                // 1. DELETE BEFEHL PR√úFEN
                try {
                    const cmd = JSON.parse(data.message);
                    if(cmd.cmd === 'DELETE') {
                        viewerMsgs = viewerMsgs.filter(m => m.ts !== cmd.ts);
                        viewerHiddenSet.add(cmd.ts); // Auf Blacklist setzen
                        updateViewerUI();
                        return;
                    }
                } catch(err){}

                const ts = data.time;

                // 2. CHECK A: Ist die Nachricht auf der Blacklist? (Sofort-Check)
                if(viewerHiddenSet.has(ts)) return; 
                
                // 3. CHECK B: Haben wir die Nachricht schon angezeigt?
                if(viewerMsgs.some(m => m.ts === ts)) return;

                let encPayload = data.attachment ? data.title : data.message;
                let imgData = data.attachment ? data.attachment.url : null;
                if(!encPayload) return;

                // --- HIER VERGEHT ZEIT (Async Decrypt) ---
                const jsonStr = await decryptText(encPayload, conf.p);
                
                if(jsonStr) {
                    try {
                        const c = JSON.parse(jsonStr);
                        let finalImg = null;
                        if (imgData) {
                            try {
                                const resp = await fetch(imgData);
                                const encBuf = await resp.arrayBuffer();
                                const decBuf = await decryptData(encBuf, conf.p);
                                if(decBuf) {
                                    const blob = new Blob([decBuf], {type: 'image/jpeg'});
                                    finalImg = URL.createObjectURL(blob);
                                }
                            } catch(err) { console.error("Live Img Error", err); }
                        }

                        // 4. CHECK C (WICHTIG!): Nochmal pr√ºfen!
                        // W√§hrend wir entschl√ºsselt haben, k√∂nnte loadViewerData die Blacklist gef√ºllt haben!
                        if(viewerHiddenSet.has(ts)) {
                            console.log("Nachricht nach Decrypt verworfen (Hidden):", ts);
                            return;
                        }
                        
                        // Auch nochmal auf Duplikate pr√ºfen (Race Condition)
                        if(viewerMsgs.some(m => m.ts === ts)) return;

                        viewerMsgs.push({
                            ts: ts,
                            sender: c.sender || '?',
                            text: c.text || '',
                            img: finalImg,
                            enc: encPayload 
                        });

                        viewerMsgs.sort((a,b) => a.ts - b.ts);
                        if(viewerIdx >= viewerMsgs.length - 2) viewerIdx = viewerMsgs.length - 1;
                        updateViewerUI();
                    } catch(e) { console.error(e); }
                }
            }
        };
    }

    // --- DELETE LOGIC ---
    async function deleteMessage(ts) {
        if(!confirm("Nachricht wirklich l√∂schen?")) return;
        
        const btn = event.currentTarget;
        const originalIcon = btn.innerHTML;
        btn.innerHTML = "‚è≥"; 
        
        try {
            const url = `https://api.github.com/repos/${conf.gu}/${conf.gr}/contents/messages.json?t=${Date.now()}`;
            const header = { 'Authorization': `Bearer ${conf.gt}`, 'Accept': 'application/vnd.github.v3+json' };
            
            const resp = await fetch(url, { headers: header, cache: "no-store" });
            if(!resp.ok) throw new Error(`GitHub Load Error: ${resp.status}`);
            
            const fileData = await resp.json();
            let rawB64 = fileData.content; 
            if (!rawB64 && fileData.sha) {
                const blobUrl = `https://api.github.com/repos/${conf.gu}/${conf.gr}/git/blobs/${fileData.sha}`;
                const blobResp = await fetch(blobUrl, { headers: header, cache: "no-store" });
                if(blobResp.ok) {
                    const blobData = await blobResp.json();
                    rawB64 = blobData.content;
                }
            }
            if (!rawB64) throw new Error("Konnte Dateiinhalt nicht laden.");
            
            const cleanB64 = rawB64.replace(/\s/g, ''); 
            const content = JSON.parse(decodeURIComponent(escape(atob(cleanB64))));
            
            let foundIndex = content.findIndex(m => m.timestamp === ts);
            
            if(foundIndex !== -1) {
                content[foundIndex].hidden = true; 
            } else {
                const localMsg = viewerMsgs.find(m => m.ts === ts);
                if(localMsg) {
                    content.push({ timestamp: ts, enc: localMsg.enc, img: null, hidden: true });
                    content.sort((a,b) => a.timestamp - b.timestamp);
                }
            }

            const newContent = btoa(unescape(encodeURIComponent(JSON.stringify(content))));
            const putUrl = `https://api.github.com/repos/${conf.gu}/${conf.gr}/contents/messages.json`;
            const updateBody = {
                message: "Delete/Hide Message via App",
                content: newContent,
                sha: fileData.sha 
            };

            const putResp = await fetch(putUrl, {
                method: 'PUT',
                headers: { 'Authorization': `Bearer ${conf.gt}`, 'Content-Type': 'application/json' },
                body: JSON.stringify(updateBody)
            });

            if(!putResp.ok) throw new Error("GitHub Save Error");

            await fetch(`https://ntfy.sh/${conf.t}`, { 
                method: 'POST', 
                body: JSON.stringify({ cmd: 'DELETE', ts: ts }) 
            });

            // Lokal entfernen
            viewerMsgs = viewerMsgs.filter(m => m.ts !== ts);
            viewerHiddenSet.add(ts); // Auf die Blacklist setzen!
            updateViewerUI();
            alert("Gel√∂scht! üóëÔ∏è");

        } catch(e) { console.error(e); alert("Fehler: " + e.message); }
        if(btn) btn.innerHTML = originalIcon;
    }

    function updateViewerUI() {
        if(!viewerMsgs || viewerMsgs.length === 0) {
            document.getElementById('viewerMeta').innerText = "Keine Nachrichten (Warte auf Live-Eingang...)";
            document.getElementById('viewerText').innerText = "";
            document.getElementById('viewerImg').style.display = 'none';
            return;
        }
        
        if(viewerIdx >= viewerMsgs.length) viewerIdx = viewerMsgs.length - 1;
        if(viewerIdx < 0) viewerIdx = 0;

        const msg = viewerMsgs[viewerIdx];
        document.getElementById('viewerText').innerText = msg.text;
        const img = document.getElementById('viewerImg');
        if(msg.img) { img.src = msg.img; img.style.display = 'block'; }
        else { img.style.display = 'none'; }
        
        const date = new Date(msg.ts * 1000).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
        
        const metaHtml = `
            <div style="display:flex; align-items:center; justify-content:center; gap:10px;">
                <span>${msg.sender} ‚Ä¢ ${date} (${viewerIdx+1}/${viewerMsgs.length})</span>
                <button onclick="deleteMessage(${msg.ts})" style="background:rgba(255,255,255,0.2); border:1px solid #666; color:white; border-radius:4px; cursor:pointer; font-size:16px; padding:2px 8px;">üóëÔ∏è</button>
            </div>
        `;
        document.getElementById('viewerMeta').innerHTML = metaHtml;
    }

    function viewerNext(dir) {
        const next = viewerIdx + dir;
        if(next >= 0 && next < viewerMsgs.length) {
            viewerIdx = next;
            updateViewerUI(); // FIX: Hier stand vorher updateViewer()
        }
    }
</script>
</body>
</html>
