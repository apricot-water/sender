<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<link rel="manifest" href="manifest.json">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Externe Libs f√ºr QR & Bildbearbeitung -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
<script src="https://unpkg.com/html5-qrcode" type="text/javascript"></script>
<link rel="apple-touch-icon" href="icon-192.png">
<title>Familien Chat</title>
<style>
    /* === VARIABLES & THEME === */
    :root {
        --bg-app: #f2f2f7; --bg-card: #ffffff; --text-main: #000000; --text-sub: #8e8e93;
        --input-bg: #e5e5ea; --accent: #007aff; --danger: #ff3b30; --sidebar-bg: #ffffff;
    }
    body.dark {
        --bg-app: #000000; --bg-card: #1c1c1e; --text-main: #ffffff; --text-sub: #98989f;
        --input-bg: #2c2c2e; --accent: #0a84ff; --sidebar-bg: #1c1c1e;
    }
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    body { margin: 0; padding: 0; font-family: -apple-system, sans-serif; background: var(--bg-app); color: var(--text-main); height: 100dvh; width: 100vw; overflow: hidden; display: flex; justify-content: center; }

    /* === LAYOUT === */
    .app-wrapper { width: 100%; max-width: 600px; background: var(--bg-card); display: flex; flex-direction: column; height: 100%; position: relative; box-shadow: 0 0 20px rgba(0,0,0,0.1); overflow: hidden; }
    
    /* === HEADER === */
    .app-header { flex: 0 0 60px; display: flex; align-items: center; justify-content: space-between; padding: 0 15px; border-bottom: 1px solid var(--input-bg); z-index: 20; background: var(--bg-card); }
    .header-title { font-weight: 700; font-size: 17px; }
    .btn-icon { background: none; border: none; cursor: pointer; color: var(--accent); padding: 8px; display: flex; align-items: center; justify-content: center; }

    /* === SIDEBAR (MENU) === */
    .sidebar-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 50; opacity: 0; pointer-events: none; transition: opacity 0.3s; }
    .sidebar-overlay.open { opacity: 1; pointer-events: auto; }
    
.sidebar { 
        position: absolute; 
        top: 0; 
        right: 0; /* √ÑNDERUNG: Rechts verankert */
        left: auto; /* Sicherheitshalber left resetten */
        bottom: 0; 
        width: 280px; 
        background: var(--sidebar-bg); 
        z-index: 51; 
        transform: translateX(100%); /* √ÑNDERUNG: Startet rechts au√üerhalb des Bildes (+100%) */
        transition: transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1); 
        padding-top: 60px; 
        display: flex; 
        flex-direction: column; 
        box-shadow: -2px 0 10px rgba(0,0,0,0.1); /* Optional: Schatten links sieht sch√∂ner aus */
    }
    
    .sidebar.open { 
        transform: translateX(0); 
    }
    
    .menu-item { padding: 15px 20px; font-size: 18px; font-weight: 500; border-bottom: 1px solid var(--input-bg); cursor: pointer; display: flex; align-items: center; gap: 15px; }
    .menu-item:active { background: var(--input-bg); }
    .menu-item.active { color: var(--accent); background: rgba(0,122,255,0.1); }
    
    /* === TABS (CONTENT) === */
    .tab-content { display: none; flex: 1; flex-direction: column; overflow: hidden; height: 100%; }
    .tab-content.active { display: flex; }

    /* === SENDER STYLES === */
    .scroll-area { flex: 1; overflow-y: auto; padding: 20px; display: flex; flex-direction: column; gap: 20px; }
    input, textarea { width: 100%; background: var(--input-bg); border: none; color: var(--text-main); padding: 16px; border-radius: 12px; font-size: 17px; font-family: inherit; resize: none; }
    input:focus, textarea:focus { outline: none; box-shadow: 0 0 0 2px var(--accent); }
    .label-small { font-size: 13px; color: var(--text-sub); margin-left: 12px; margin-bottom: 6px; font-weight: 500; text-transform: uppercase; }
    .media-upload { background: var(--input-bg); border-radius: 12px; padding: 20px; text-align: center; cursor: pointer; border: 2px dashed rgba(128,128,128,0.3); }
    .media-preview-img { width: 100%; height: 200px; object-fit: cover; border-radius: 8px; display: none; margin-top: 10px; }
    .bottom-bar { padding: 20px; border-top: 1px solid var(--input-bg); padding-bottom: calc(20px + env(safe-area-inset-bottom)); }
    .btn-primary { width: 100%; background: linear-gradient(135deg, #007aff, #005ecb); color: white; font-size: 17px; font-weight: 600; padding: 14px; border: none; border-radius: 12px; cursor: pointer; }
    
    /* === VIEWER STYLES (Mini Version of empf√§nger.html) === */
    .viewer-container { flex: 1; background: #000; display: flex; flex-direction: column; align-items: center; justify-content: center; position: relative; color: white; text-align: center; padding: 10px; }
    .viewer-img { max-width: 100%; max-height: 50vh; object-fit: contain; border-radius: 10px; margin-bottom: 15px; display: none; }
    .viewer-text { font-size: 24px; font-weight: bold; line-height: 1.3; max-height: 40vh; overflow-y: auto; width: 100%; }
    .viewer-meta { position: absolute; top: 10px; width: 100%; text-align: center; color: #666; font-size: 12px; }
    .viewer-nav { position: absolute; top: 50%; width: 100%; display: flex; justify-content: space-between; padding: 0 10px; pointer-events: none; }
    .nav-btn { pointer-events: auto; background: rgba(255,255,255,0.2); border: none; color: white; font-size: 24px; width: 50px; height: 50px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; }
    .nav-btn:active { background: rgba(255,255,255,0.4); }

    /* === SETTINGS MODAL === */
    #settingsModal { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: var(--bg-card); z-index: 100; transform: translateY(100%); transition: transform 0.3s; display: flex; flex-direction: column; }
    #settingsModal.open { transform: translateY(0); }
    .setting-row { padding: 15px; border-bottom: 1px solid var(--input-bg); }
    
    #toast { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.9); background: rgba(0,0,0,0.85); color: white; padding: 15px 25px; border-radius: 30px; opacity: 0; pointer-events: none; transition: 0.2s; z-index: 200; }
    #toast.show { opacity: 1; transform: translate(-50%, -50%) scale(1); }
/* === PROGRESS OVERLAY === */
    #progressOverlay {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.4); backdrop-filter: blur(5px);
        z-index: 200;
        display: flex; align-items: center; justify-content: center;
        opacity: 0; pointer-events: none; transition: opacity 0.3s;
    }
    #progressOverlay.open { opacity: 1; pointer-events: auto; }

    .progress-card {
        background: var(--bg-card); width: 80%; max-width: 300px;
        padding: 25px; border-radius: 20px; text-align: center;
        box-shadow: 0 10px 40px rgba(0,0,0,0.2);
    }
    
    .progress-title { font-size: 18px; font-weight: 600; margin-bottom: 15px; }
    .progress-status { font-size: 13px; color: var(--text-sub); margin-bottom: 15px; min-height: 1.2em;}

    .progress-track {
        background: var(--input-bg); height: 8px; border-radius: 4px; overflow: hidden; position: relative;
    }
    .progress-bar {
        background: var(--accent); height: 100%; width: 0%;
        transition: width 0.2s; border-radius: 4px;
    }
/* === LOG TAB STYLES === */
    .log-container { padding: 15px; }
    .log-item { 
        background: var(--input-bg); 
        padding: 15px; 
        border-radius: 12px; 
        margin-bottom: 12px; 
        display: flex; 
        align-items: flex-start; 
        position: relative;
        animation: fadeIn 0.3s ease;
    }
    .log-icon { 
        font-size: 24px; 
        margin-right: 15px; 
        background: var(--bg-card); 
        width: 40px; height: 40px; 
        display: flex; align-items: center; justify-content: center; 
        border-radius: 50%; flex-shrink: 0;
    }
    .log-content { flex: 1; }
    .log-title { font-weight: 600; font-size: 15px; margin-bottom: 4px; display: flex; justify-content: space-between; }
    .log-meta { font-size: 12px; color: var(--text-sub); display: flex; align-items: center; gap: 8px; }
    .log-badge { 
        background: var(--accent); color: white; 
        padding: 2px 8px; border-radius: 6px; 
        font-size: 10px; font-weight: bold; text-transform: uppercase; letter-spacing: 0.5px;
    }
    .log-snippet { 
        margin-top: 8px; font-size: 14px; color: var(--text-main); 
        background: rgba(128,128,128,0.1); padding: 8px; border-radius: 8px; font-style: italic;
    }
    .log-empty { text-align: center; color: var(--text-sub); margin-top: 50px; }
    
    @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }

/* === TOUR / ONBOARDING STYLES === */
    #tour-layer {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 5000;
        display: none; pointer-events: auto; overflow: hidden;
    }
    /* Der Spotlight-Effekt: Ein riesiger Schatten um das transparente Element */
    #tour-spotlight {
        position: absolute;
        box-shadow: 0 0 0 4000px rgba(0, 0, 0, 0.8);
        border-radius: 8px;
        transition: all 0.3s cubic-bezier(0.25, 1, 0.5, 1);
        pointer-events: none; /* Klicks gehen durch */
        border: 2px solid var(--accent);
    }
    .tour-card {
        position: absolute;
        background: var(--bg-card);
        color: var(--text-main);
        width: 90%; max-width: 320px;
        padding: 20px;
        border-radius: 16px;
        box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        transition: opacity 0.3s, transform 0.3s;
        z-index: 5001;
    }
    .tour-title { font-weight: bold; font-size: 18px; margin-bottom: 8px; display:flex; align-items:center; gap:8px;}
    .tour-text { font-size: 15px; color: var(--text-sub); line-height: 1.4; margin-bottom: 20px; }
    .tour-footer { display: flex; justify-content: space-between; align-items: center; }
    .tour-dots { display: flex; gap: 4px; }
    .tour-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--input-bg); }
    .tour-dot.active { background: var(--accent); }
    .btn-tour { padding: 8px 16px; border-radius: 8px; font-weight: 600; font-size: 14px; cursor: pointer; border: none; }
    .btn-tour-skip { background: transparent; color: var(--text-sub); }
    .btn-tour-next { background: var(--accent); color: white; }

/* === NEW MODALS (QR & CROPPER) === */
    .modal-fullscreen {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: var(--bg-card); z-index: 2000;
        display: none; flex-direction: column;
    }
    .modal-fullscreen.active { display: flex; }
    
    .editor-area { flex: 1; background: #000; position: relative; overflow: hidden; }
    .editor-controls { padding: 15px; background: var(--bg-card); display: flex; gap: 10px; justify-content: center; }
    
    .qr-container { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 20px; text-align: center; }
    #qrCodeDiv { margin: 20px 0; padding: 10px; background: white; border-radius: 8px; }
    #qrReader { width: 100%; max-width: 400px; }

    /* WICHTIG: min-height erzwingen, sonst sieht die Library keinen Platz */
    #qrReader { 
        width: 100%; 
        min-height: 300px; 
        background: #000; 
        border-radius: 8px;
        overflow: hidden;
    }
    #qrReader { 
        width: 100%; 
        min-height: 300px; /* Zwingend n√∂tig f√ºr mobilen Chrome */
        background: #000; 
        border-radius: 8px;
        overflow: hidden;
        position: relative;
    }
    /* Versteckt das h√§ssliche "Scan region" overlay der Library, falls es auftaucht */
    #qrReader__scan_region { display: none !important; }
</style>
</head>
<body>

<div class="app-wrapper">
    <!-- PROGRESS OVERLAY -->
    <div id="progressOverlay">
        <div class="progress-card">
            <div class="progress-title">Sende Nachricht...</div>
            <div id="progressStatus" class="progress-status">Vorbereitung...</div>
            <div class="progress-track">
                <div id="progressBar" class="progress-bar"></div>
            </div>
            <div id="progressPercent" style="font-size:12px; margin-top:5px; color:var(--text-sub)">0%</div>
        </div>
    </div>
    
   <!-- HEADER -->
    <header class="app-header">
        <!-- Titel jetzt links -->
        <div class="header-title" id="pageTitle">Nachricht schreiben</div>
        
        <!-- Rechte Seite: Einstellungen + Men√º gruppiert -->
        <div style="display: flex; align-items: center; gap: 5px;">
            <button class="btn-icon" onclick="toggleSettings(true)">‚öôÔ∏è</button>
            
            <button class="btn-icon" onclick="toggleSidebar(true)">
                <!-- Hamburger Icon -->
                <svg width="24" height="24" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" stroke-linecap="round"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg>
            </button>
        </div>
    </header>

    <!-- SIDEBAR -->
    <div class="sidebar-overlay" onclick="toggleSidebar(false)"></div>
    <div class="sidebar">
        <div style="padding: 0 20px 20px 20px; font-weight:bold; font-size:20px; color:var(--text-sub)">Men√º</div>
        <div class="menu-item active" onclick="switchTab('send')">‚úçÔ∏è Schreiben</div>
        <div class="menu-item" onclick="switchTab('view')">üõ†Ô∏èNachrichten bearbeiten</div>
        <div class="menu-item" onclick="switchTab('log')">üìä Aktivit√§ten Log</div>
        <div style="flex:1"></div>
        <div class="menu-item" style="font-size:14px; color:var(--text-sub)" onclick="toggleDarkMode()">üåô Dark Mode umschalten</div>
    </div>

    <!-- TAB: SENDER -->
    <div id="tab-send" class="tab-content active">
        <div class="scroll-area">
            <div>
                <div class="label-small">Dein Name</div>
                <input id="senderName" placeholder="Name">
            </div>
            <div style="flex:1; display:flex; flex-direction:column;">
                <div class="label-small">Nachricht</div>
                <textarea id="msgText" placeholder="Hallo Oma..." style="flex:1; min-height:150px;"></textarea>
            </div>
            <div class="media-upload" onclick="document.getElementById('fileInput').click()">
                <div style="font-size:24px; opacity:0.5">üì∑</div>
                <div id="mediaText" style="font-weight:600; color:var(--accent); margin-top:5px">Foto anh√§ngen</div>
                <img id="imagePreview" class="media-preview-img">
                <input type="file" id="fileInput" accept="image/*" style="display:none" onchange="previewFile()">
            </div>
        </div>
        <div class="bottom-bar">
            <button id="btnSend" class="btn-primary" onclick="send()">Senden üöÄ</button>
        </div>
    </div>

    <!-- TAB: VIEWER -->
    <div id="tab-view" class="tab-content">
        <div class="viewer-container">
            <div class="viewer-meta" id="viewerMeta">Lade Daten...</div>
            <img id="viewerImg" class="viewer-img">
            <div id="viewerText" class="viewer-text"></div>
            
            <div class="viewer-nav">
                <button class="nav-btn" onclick="viewerNext(-1)">‚ùÆ</button>
                <button class="nav-btn" onclick="viewerNext(1)">‚ùØ</button>
            </div>
        </div>
        <div style="padding:10px; text-align:center; font-size:11px; color:var(--text-sub); background:#000;">
            Vorschau (Aktualisiert alle 30m via GitHub)
        </div>
    </div>

<!-- TAB: LOG -->
    <div id="tab-log" class="tab-content">
        <div style="padding:15px; border-bottom:1px solid var(--input-bg); display:flex; justify-content:space-between; align-items:center; background:var(--bg-card);">
            <span style="font-size:13px; color:var(--text-sub)" id="logStatus">Bereit</span>
            <button onclick="loadLogData()" style="background:none; border:none; color:var(--accent); font-weight:bold; cursor:pointer;">‚Üª Aktualisieren</button>
        </div>
        <div class="scroll-area" id="logList">
            <!-- Hier kommen die Logs rein -->
            <div class="log-empty">Lade Logs...</div>
        </div>
    </div>

    
    <!-- SETTINGS -->
    <div id="settingsModal">
        <header class="app-header">
            <div class="header-title">Einstellungen</div>
            <button class="btn-icon" onclick="saveConf()">Fertig</button>
        </header>
        <button class="btn-primary" style="margin-top:20px; background: #5856d6;" onclick="toggleQrModal(true)">üì± QR Code Setup</button>
        <div class="scroll-area">
            <div class="label-small">Kanal Name (ntfy)</div>
            <input id="confTopic" placeholder="oma_geheim">
            <div class="label-small" style="margin-top:15px">Passwort</div>
            <input id="confPass" type="text" placeholder="Geheim">
            
            <hr style="border:0; border-top:1px solid var(--input-bg); margin: 20px 0;">
            <div class="label-small">GitHub User</div>
            <input id="confGhUser" placeholder="z.B. deinUser">
            <div class="label-small" style="margin-top:15px">GitHub Repo</div>
            <input id="confGhRepo" placeholder="z.B. oma-chat">
            <div class="label-small" style="margin-top:15px">GitHub Token</div>
            <input id="confGhToken" type="password" placeholder="github_pat_...">
            <div style="font-size:11px; color:var(--text-sub); margin-top:5px">Ben√∂tigt f√ºr den Verlauf ("Omas Sicht").</div>
        </div>
    </div>

    <div id="toast">Nachricht gesendet!</div>
</div>
<!-- ONBOARDING TOUR UI -->
    <div id="tour-layer">
        <div id="tour-spotlight"></div>
        <div id="tour-card" class="tour-card">
            <div class="tour-title" id="tourTitle">üëã Willkommen!</div>
            <div class="tour-text" id="tourText">Lass uns kurz die wichtigsten Funktionen anschauen.</div>
            <div class="tour-footer">
                <button class="btn-tour btn-tour-skip" onclick="tour.end()">Beenden</button>
                <div class="tour-dots" id="tourDots"></div>
                <button class="btn-tour btn-tour-next" id="tourNextBtn" onclick="tour.next()">Starten</button>
            </div>
        </div>
    </div>
    <!-- EDITOR MODAL -->
    <div id="editorModal" class="modal-fullscreen">
        <header class="app-header">
            <button class="btn-icon" onclick="closeEditor()">Abbrechen</button>
            <div class="header-title">Bild bearbeiten</div>
            <button class="btn-icon" onclick="saveEditor()">Fertig</button>
        </header>
        <div class="editor-area">
            <img id="editorImage" style="max-width: 100%;">
        </div>
        <div class="editor-controls">
            <button class="btn-icon" onclick="cropper.rotate(-90)">‚Ü∫</button>
            <button class="btn-icon" onclick="cropper.rotate(90)">‚Üª</button>
            <button class="btn-icon" onclick="cropper.reset()">Reset</button>
        </div>
    </div>

    <!-- QR MODAL -->
    <div id="qrModal" class="modal-fullscreen">
        <header class="app-header">
            <button class="btn-icon" onclick="toggleQrModal(false)">Schlie√üen</button>
            <div class="header-title">Setup teilen / Scannen</div>
            <div style="width: 40px;"></div>
        </header>
        <div class="scroll-area">
            <!-- TAB W√ÑHLER -->
            <div style="display:flex; margin-bottom:20px; background:var(--input-bg); padding:4px; border-radius:10px;">
                <div style="flex:1; text-align:center; padding:8px; border-radius:8px; background:var(--bg-card); font-weight:bold; cursor:pointer;" onclick="showQrTab('gen')">Zeigen</div>
                <div style="flex:1; text-align:center; padding:8px; cursor:pointer;" onclick="showQrTab('scan')">Scannen</div>
            </div>

            <!-- GENERATE VIEW -->
            <div id="qrGenView" class="qr-container">
                <div style="font-size:14px; color:var(--text-sub)">Diesen Code mit einem anderen Ger√§t scannen, um die Einstellungen zu kopieren.</div>
                <div id="qrCodeDiv"></div>
                <!-- Im HTML unter dem div id="qrCodeDiv" einf√ºgen -->
<button class="btn-primary" style="margin-top:10px; font-size:14px;" onclick="copyLink()">Link kopieren üìã</button>
                <div style="color:var(--danger); font-size:12px; font-weight:bold;">‚ö†Ô∏è Enth√§lt Passw√∂rter! Nicht √∂ffentlich zeigen.</div>
            </div>
        
            
            <!-- SCAN VIEW -->
            <div id="qrScanView" class="qr-container" style="display:none">
                <div id="qrReader"></div>
                <div id="scanStatus" style="margin-top:10px; font-size:13px;">Kamera Zugriff erlauben...</div>
            </div>
        </div>
    </div>
<script>
    // --- 1. MAGIC LINK & CONFIG ---
    let conf = { t: '', p: '', gu: '', gr: '', gt: '' };

    (function initConfig() {
        try { Object.assign(conf, JSON.parse(localStorage.getItem('oma_conf_v2') || '{}')); } catch(e){}
        const hash = window.location.hash;
        if (hash.startsWith('#config=')) {
            try {
                const json = JSON.parse(atob(hash.substring(8)));
                Object.assign(conf, json);
                localStorage.setItem('oma_conf_v2', JSON.stringify(conf));
                history.replaceState(null, null, window.location.pathname);
              //  alert("Einstellungen importiert! üéâ");
            } catch(e) { alert("Link fehlerhaft."); }
        }
        document.getElementById('confTopic').value = conf.t || '';
        document.getElementById('confPass').value = conf.p || '';
        document.getElementById('confGhUser').value = conf.gu || '';
        document.getElementById('confGhRepo').value = conf.gr || '';
        document.getElementById('confGhToken').value = conf.gt || '';
        if (localStorage.getItem('darkmode') === 'true') document.body.classList.add('dark');
    })();
    // --- DRAFTS ---
    const draftName = localStorage.getItem('draft_name');
    const draftMsg = localStorage.getItem('draft_msg');
    if(draftName) document.getElementById('senderName').value = draftName;
    if(draftMsg) document.getElementById('msgText').value = draftMsg;

    // Listener hinzuf√ºgen
    document.getElementById('senderName').addEventListener('input', (e) => localStorage.setItem('draft_name', e.target.value));
    document.getElementById('msgText').addEventListener('input', (e) => localStorage.setItem('draft_msg', e.target.value));
    
 

    function saveConf() {
        conf.t = document.getElementById('confTopic').value.trim();
        conf.p = document.getElementById('confPass').value.trim();
        conf.gu = document.getElementById('confGhUser').value.trim();
        conf.gr = document.getElementById('confGhRepo').value.trim();
        conf.gt = document.getElementById('confGhToken').value.trim();
        localStorage.setItem('oma_conf_v2', JSON.stringify(conf));
        toggleSettings(false);
        if(activeTab === 'view') { loadViewerData(); startLiveViewer(); }
    }
function copyLink() {
        const jsonConf = JSON.stringify(conf);
        const payload = window.location.href.split('#')[0] + "#config=" + btoa(jsonConf);
        navigator.clipboard.writeText(payload).then(() => alert("Link kopiert! Sende ihn an das andere Handy."));
    }
    
    // --- 2. UI NAVIGATION ---
    let activeTab = 'send';
    function toggleSidebar(open) {
        const s = document.querySelector('.sidebar');
        const o = document.querySelector('.sidebar-overlay');
        if(open) { s.classList.add('open'); o.classList.add('open'); }
        else { s.classList.remove('open'); o.classList.remove('open'); }
    }
    
    function toggleSettings(open) {
        document.getElementById('settingsModal').classList.toggle('open', open);
    }
    
    function toggleDarkMode() {
        document.body.classList.toggle('dark');
        localStorage.setItem('darkmode', document.body.classList.contains('dark'));
    }

    function showToast(msg) {
        const t = document.getElementById('toast'); t.innerText = msg; t.classList.add('show');
        setTimeout(() => t.classList.remove('show'), 2000);
    }

    // --- 3. CRYPTO UTILS ---
    const enc = new TextEncoder(); const dec = new TextDecoder();

    async function getKey(p, s){ 
        const k=await window.crypto.subtle.importKey("raw",enc.encode(p),{name:"PBKDF2"},false,["deriveKey"]); 
        return window.crypto.subtle.deriveKey({name:"PBKDF2",salt:s,iterations:100000,hash:"SHA-256"},k,{name:"AES-GCM",length:256},true,["encrypt","decrypt"]); 
    }

    function concatBuffers(salt, iv, data) {
        const tmp = new Uint8Array(salt.byteLength + iv.byteLength + data.byteLength);
        tmp.set(new Uint8Array(salt), 0);
        tmp.set(new Uint8Array(iv), salt.byteLength);
        tmp.set(new Uint8Array(data), salt.byteLength + iv.byteLength);
        return tmp.buffer;
    }

    async function encryptText(txt, pass){ 
        const raw = enc.encode(txt);
        const buf = await encryptData(raw, pass);
        let binary = ''; const bytes = new Uint8Array(buf);
        for (let i = 0; i < bytes.byteLength; i++) binary += String.fromCharCode(bytes[i]);
        return btoa(binary);
    }

    async function encryptData(dataBuffer, pass) {
        const s = window.crypto.getRandomValues(new Uint8Array(16)); 
        const iv = window.crypto.getRandomValues(new Uint8Array(12)); 
        const k = await getKey(pass, s); 
        const e = await window.crypto.subtle.encrypt({name:"AES-GCM",iv:iv}, k, dataBuffer); 
        return concatBuffers(s, iv, e);
    }

    async function decryptData(buffer, pass) {
        try {
            const bytes = new Uint8Array(buffer);
            const s = bytes.slice(0,16);
            const iv = bytes.slice(16,28);
            const data = bytes.slice(28);
            const k = await getKey(pass, s);
            return await window.crypto.subtle.decrypt({name:"AES-GCM",iv:iv}, k, data);
        } catch(e) { console.error("Decrypt Fail", e); return null; }
    }
    
    async function decryptText(b64, pass) {
        try {
            const binStr = atob(b64);
            const buf = new Uint8Array(binStr.length);
            for(let i=0; i<binStr.length; i++) buf[i] = binStr.charCodeAt(i);
            const decBuf = await decryptData(buf.buffer, pass);
            return decBuf ? dec.decode(decBuf) : null;
        } catch(e) { return null; }
    }
    
    function base64ToBuffer(b64) {
        const bin = atob(b64);
        const len = bin.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) bytes[i] = bin.charCodeAt(i);
        return bytes.buffer;
    }

    // --- 4. SENDER LOGIC ---
    function compressImage(file) { 
        return new Promise((resolve, reject) => {
            const reader = new FileReader(); reader.readAsDataURL(file);
            reader.onload = (event) => {
                const img = new Image(); img.src = event.target.result;
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const MAX = 1200; 
                    let w=img.width, h=img.height; 
                    if(w>h){if(w>MAX){h*=MAX/w;w=MAX;}}else{if(h>MAX){w*=MAX/h;h=MAX;}} 
                    canvas.width=w; canvas.height=h; 
                    const ctx=canvas.getContext("2d"); ctx.drawImage(img,0,0,w,h);
                    canvas.toBlob((b)=>resolve(b),'image/jpeg',0.7);
                };
            };
        });
    }

 async function send() {
        if(!conf.t || !conf.p) return alert("Einstellungen pr√ºfen!");
        const name = document.getElementById('senderName').value || "Familie";
        const text = document.getElementById('msgText').value;
        const fileInput = document.getElementById('fileInput').files[0];
        
        // PR√úFUNG: Gibt es ein bearbeitetes Bild (Blob) oder ein Original (Input)?
        const hasImage = window.currentUploadBlob || fileInput;

        if(!text && !hasImage) return showToast("Leer?");

        const overlay = document.getElementById('progressOverlay');
        const status = document.getElementById('progressStatus');
        const bar = document.getElementById('progressBar');
        const perc = document.getElementById('progressPercent');
        overlay.classList.add('open'); bar.style.width='0%'; perc.innerText='0%';

        try {
            const payload = JSON.stringify({ sender: name, text: text, timestamp: Date.now() });
            const encTitle = await encryptText(payload, conf.p);
            
            let dataToSend = encTitle; 
            
            if(hasImage) {
                status.innerText = "Verarbeite Bild..."; bar.style.width='20%';
                
                let fileBuf;
                
                // FALL A: Bild kommt aus dem Editor (ist schon komprimiert/resized)
                if (window.currentUploadBlob) {
                    fileBuf = await window.currentUploadBlob.arrayBuffer();
                } 
                // FALL B: Bild kommt direkt vom Input (muss noch komprimiert werden)
                else {
                    status.innerText = "Komprimiere...";
                    const compressedBlob = await compressImage(fileInput);
                    fileBuf = await compressedBlob.arrayBuffer();
                }

                status.innerText = "Verschl√ºssele Bild..."; bar.style.width='40%';
                const encFileBuf = await encryptData(fileBuf, conf.p);
                dataToSend = new Blob([encFileBuf]);
            }

            status.innerText = "Lade hoch...";
            await new Promise((resolve, reject) => {
                const xhr = new XMLHttpRequest();
                const url = `https://ntfy.sh/${conf.t}`;
                
                if (hasImage) {
                    xhr.open('PUT', url);
                    xhr.setRequestHeader('Title', encTitle);
                    xhr.setRequestHeader('Filename', 'secure.bin');
                } else {
                    xhr.open('POST', url);
                    xhr.setRequestHeader('Title', 'Message');
                }

                xhr.upload.onprogress = (e) => {
                    if (e.lengthComputable) {
                        const vp = 40 + ((e.loaded/e.total)*60);
                        bar.style.width = vp+'%'; perc.innerText = Math.round(vp)+'%';
                    }
                };
                xhr.onload = () => (xhr.status >= 200 && xhr.status < 300) ? resolve() : reject(xhr.status);
                xhr.onerror = () => reject("Network Error");
                xhr.send(dataToSend);
            });

            // ERFOLG!
            bar.style.width='100%'; status.innerText="Fertig!";
            
            // Entwurf NUR bei Erfolg l√∂schen
            localStorage.removeItem('draft_msg'); 
            // Name (draft_name) behalten wir absichtlich im Speicher

            // Aufr√§umen
            window.currentUploadBlob = null; // Wichtig: Editor-Cache leeren
            
            setTimeout(() => {
                overlay.classList.remove('open'); showToast("Sicher gesendet! üîí");
                document.getElementById('msgText').value=""; 
                document.getElementById('fileInput').value=""; 
                document.getElementById('imagePreview').style.display='none';
                document.getElementById('mediaText').innerText="Foto anh√§ngen"; // Reset Text
            }, 500);

        } catch(e) {
            alert("Fehler: " + e); overlay.classList.remove('open');
            // Hier NICHT den Draft l√∂schen, damit der User es nochmal versuchen kann
        }
    }

// --- IMAGE EDITOR ---
    let cropper = null;
    let originalFile = null;

    function previewFile() {
        const file = document.getElementById('fileInput').files[0];
        if(!file) return;
        originalFile = file;

        // Editor √∂ffnen statt direkt anzeigen
        const reader = new FileReader();
        reader.onload = (e) => {
            document.getElementById('editorImage').src = e.target.result;
            document.getElementById('editorModal').classList.add('active');
            
            // Cropper starten
            if(cropper) cropper.destroy();
            const image = document.getElementById('editorImage');
            cropper = new Cropper(image, {
                viewMode: 1,
                dragMode: 'move',
                autoCropArea: 1,
            });
        };
        reader.readAsDataURL(file);
    }

    function closeEditor() {
        document.getElementById('editorModal').classList.remove('active');
        document.getElementById('fileInput').value = ""; // Reset
        if(cropper) cropper.destroy();
    }

    function saveEditor() {
        if(!cropper) return;
        // Canvas holen
        cropper.getCroppedCanvas({ maxWidth: 1200, maxHeight: 1200 }).toBlob((blob) => {
            // Blob als File "faken" f√ºr den existierenden Upload-Prozess
            // Wir erstellen ein neues File Object
            const newFile = new File([blob], "edited.jpg", { type: "image/jpeg" });
            
            // UI Update (das alte Preview Element)
            const img = document.getElementById('imagePreview');
            img.src = URL.createObjectURL(blob);
            img.style.display = 'block';
            document.getElementById('mediaText').innerText = "Bild √§ndern";
            
            // Hack: Wir √ºberschreiben die property im Input nicht (security), 
            // aber wir speichern das Blob global f√ºr die send() funktion.
            window.currentUploadBlob = blob; 

            document.getElementById('editorModal').classList.remove('active');
            cropper.destroy();
        }, 'image/jpeg', 0.8);
    }

// --- 5. VIEWER LOGIC (CLEAN VERSION) ---
    // Wir nutzen eine Map: Key = Timestamp. Das verhindert Duplikate zu 100%.
    let msgMap = new Map(); 
    let viewerMsgs = []; // Das Array f√ºr die Anzeige (wird aus der Map generiert)
    let viewerIdx = 0;
    let viewerHiddenSet = new Set();
    let eventSource = null;

    function resetViewer() {
        msgMap.clear();
        viewerMsgs = [];
        viewerIdx = 0;
        viewerHiddenSet.clear();
        document.getElementById('viewerMeta').innerText = "Lade Daten...";
        document.getElementById('viewerImg').style.display = 'none';
        document.getElementById('viewerText').innerText = "";
        
        // Alte Verbindung kappen
        if(eventSource) {
            eventSource.close();
            eventSource = null;
        }
    }

    // Zentrale Funktion: F√ºgt Nachricht hinzu (egal woher sie kommt)
    function addMessageToView(msgObj) {
        // 1. Check: Ist sie gel√∂scht?
        if(viewerHiddenSet.has(msgObj.ts)) return;
        
        // 2. Check: Haben wir die schon? (Der Map-Trick)
        if(msgMap.has(msgObj.ts)) return; 

        // Neu hinzuf√ºgen
        msgMap.set(msgObj.ts, msgObj);
        
        // Map in Array umwandeln und sortieren
        viewerMsgs = Array.from(msgMap.values()).sort((a,b) => a.ts - b.ts);
        
        // Wenn wir vorher "am Ende" waren oder es die erste Nachricht ist -> ans Ende springen
        if(viewerMsgs.length === 1 || viewerIdx >= viewerMsgs.length - 2) {
            viewerIdx = viewerMsgs.length - 1;
        }
        
        updateViewerUI();
    }

    // Startpunkt (wird beim Tab-Wechsel aufgerufen)
function switchTab(tab) {
        activeTab = tab;
        document.querySelectorAll('.tab-content').forEach(e => e.classList.remove('active'));
        document.getElementById('tab-' + tab).classList.add('active');
        document.querySelectorAll('.menu-item').forEach(e => e.classList.remove('active'));
        if(event && event.currentTarget) event.currentTarget.classList.add('active'); 
        toggleSidebar(false);

        if(tab === 'send') document.getElementById('pageTitle').innerText = "Nachricht schreiben";
        
        if(tab === 'view') {
            document.getElementById('pageTitle').innerText = "Omas Sicht";
            resetViewer();
            startLiveViewer(); 
            loadGithubData(); 
        }

        // NEU: Log Tab Logik
        if(tab === 'log') {
            document.getElementById('pageTitle').innerText = "Aktivit√§ten";
            loadLogData();
        }
    }

    // QUELLE 1: GitHub (Archiv)
    // --- SMART CACHING ---
    async function loadGithubData() {
        if(!conf.gu || !conf.gr || !conf.gt) return;
        
        try {
            // 1. Metadaten holen (sehr klein)
            const url = `https://api.github.com/repos/${conf.gu}/${conf.gr}/contents/messages.json?t=${Date.now()}`;
            const header = { 'Authorization': `Bearer ${conf.gt}`, 'Accept': 'application/vnd.github.v3+json' };
            const resp = await fetch(url, { headers: header });
            
            if(!resp.ok) throw new Error("GitHub Fehler");
            
            const fileData = await resp.json();
            const serverSha = fileData.sha;
            const localSha = localStorage.getItem('cache_sha_msgs');
            
            let rawData = [];

            // 2. Pr√ºfen: Haben wir das schon?
            if (serverSha === localSha && localStorage.getItem('cache_content_msgs')) {
                console.log("‚ö° Nutze Cache!");
                rawData = JSON.parse(localStorage.getItem('cache_content_msgs'));
            } else {
                console.log("üì• Lade neu von GitHub...");
                // Download Content
                let rawB64 = fileData.content;
                if (!rawB64 && fileData.sha) {
                    const blobResp = await fetch(`https://api.github.com/repos/${conf.gu}/${conf.gr}/git/blobs/${fileData.sha}`, { headers: header });
                    if(blobResp.ok) {
                        const blobData = await blobResp.json();
                        rawB64 = blobData.content;
                    }
                }
                if(!rawB64) return;

                const cleanB64 = rawB64.replace(/\s/g, ''); 
                rawData = JSON.parse(decodeURIComponent(escape(atob(cleanB64))));
                
                // Cache updaten
                try {
                    localStorage.setItem('cache_sha_msgs', serverSha);
                    localStorage.setItem('cache_content_msgs', JSON.stringify(rawData));
                } catch(e) { console.log("Cache voll", e); }
            }

            // 3. Verarbeiten (wie bisher)
            for(let item of rawData) {
                if(item.hidden) { viewerHiddenSet.add(item.timestamp); continue; }
                processAndAdd(item.timestamp, item.enc, item.img);
            }
        } catch(e) { console.log("GitHub Load Error:", e); }
    }
    
    // QUELLE 2: ntfy (Live & Cache)
    function startLiveViewer() {
        if(!conf.t) return;
        eventSource = new EventSource(`https://ntfy.sh/${conf.t}/sse?since=all`);
        
        eventSource.onmessage = (e) => {
            const data = JSON.parse(e.data);
            if(data.event === 'message') {
                // Delete Befehl?
                try {
                    const cmd = JSON.parse(data.message);
                    if(cmd.cmd === 'DELETE') {
                        handleDelete(cmd.ts);
                        return;
                    }
                } catch(err){}

                const ts = data.time;
                let encPayload = data.attachment ? data.title : data.message;
                let imgUrl = data.attachment ? data.attachment.url : null;
                
                // Da imgUrl eine URL ist, m√ºssen wir das Bild erst laden, 
                // falls wir das Archiv-Format simulieren wollen.
                // Aber: F√ºr den Viewer reicht die URL (wir entschl√ºsseln sie sp√§ter).
                // HIER: Wir √ºbergeben die URL an die Process Funktion.
                
                // ACHTUNG: Bei ntfy ist das Bild noch verschl√ºsselt auf dem Server.
                // Wir m√ºssen es in processAndAdd laden und entschl√ºsseln.
                processAndAdd(ts, encPayload, null, imgUrl);
            }
        };
    }

    // KERN: Entschl√ºsseln und zur Map hinzuf√ºgen
    async function processAndAdd(ts, encText, imgBase64, imgUrlFromNtfy = null) {
        if(!encText) return;
        
        // 1. Text entschl√ºsseln
        const jsonStr = await decryptText(encText, conf.p);
        if(!jsonStr) return; // Falsches Passwort oder M√ºlldaten

        try {
            const content = JSON.parse(jsonStr);
            let finalImg = null;

            // 2. Bild verarbeiten
            // Fall A: Bild kommt direkt aus GitHub (Base64 String)
            if (imgBase64) {
                 try {
                    const encBuf = base64ToBuffer(imgBase64);
                    const decBuf = await decryptData(encBuf, conf.p);
                    if(decBuf) {
                        const blob = new Blob([decBuf], {type: 'image/jpeg'});
                        finalImg = URL.createObjectURL(blob);
                    }
                 } catch(err) {}
            }
            // Fall B: Bild kommt von ntfy (URL) -> Downloaden & Entschl√ºsseln
            else if (imgUrlFromNtfy) {
                 try {
                    const resp = await fetch(imgUrlFromNtfy);
                    if(resp.ok) {
                        const encBuf = await resp.arrayBuffer();
                        const decBuf = await decryptData(encBuf, conf.p);
                        if(decBuf) {
                            const blob = new Blob([decBuf], {type: 'image/jpeg'});
                            finalImg = URL.createObjectURL(blob);
                        }
                    }
                 } catch(err) {}
            }

            // 3. Objekt bauen
            const msgObj = {
                ts: ts,
                sender: content.sender || '?',
                text: content.text || '',
                img: finalImg,
                enc: encText // Behalten f√ºr interne Zwecke
            };

            // 4. Ab in die UI damit
            addMessageToView(msgObj);

        } catch(e) { console.error(e); }
    }

    function handleDelete(ts) {
        viewerHiddenSet.add(ts);
        msgMap.delete(ts);
        viewerMsgs = Array.from(msgMap.values()).sort((a,b) => a.ts - b.ts);
        updateViewerUI();
    }

    // --- UI UPDATE & DELETE (Rest bleibt gleich) ---
    async function deleteMessage(ts) {
        if(!confirm("L√∂schen?")) return;
        
        // 1. GitHub Update (Hidden setzen)
        try {
            // ... (Hier dein bestehender GitHub Delete Code, den k√∂nnen wir so lassen)
            // Kurzfassung: Nur den API Call machen
            const url = `https://api.github.com/repos/${conf.gu}/${conf.gr}/contents/messages.json`;
            // ... (der Code ist komplex, ich nehme an du hast ihn noch im Kopf/Zwischenablage
            // oder willst ihn behalten? Falls er weg ist, sag bescheid)
            
            // Simpler Hack f√ºr jetzt, damit UI reagiert:
            handleDelete(ts); 
            
            // Delete-Command an ntfy senden
             await fetch(`https://ntfy.sh/${conf.t}`, { 
                method: 'POST', 
                body: JSON.stringify({ cmd: 'DELETE', ts: ts }) 
            });

        } catch(e) { alert("Delete Error (siehe Konsole)"); console.error(e); }
    }

    function updateViewerUI() {
        if(viewerMsgs.length === 0) {
            document.getElementById('viewerMeta').innerText = "Keine Nachrichten gefunden.";
            return;
        }

        if(viewerIdx >= viewerMsgs.length) viewerIdx = viewerMsgs.length - 1;
        if(viewerIdx < 0) viewerIdx = 0;

        const msg = viewerMsgs[viewerIdx];
        document.getElementById('viewerText').innerText = msg.text;
        
        const img = document.getElementById('viewerImg');
        if(msg.img) { 
            img.src = msg.img; 
            img.style.display = 'block'; 
        } else { 
            img.style.display = 'none'; 
        }
        
        const date = new Date(msg.ts * 1000).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
        
        // HTML f√ºr Meta Infos + Delete Button
        // Nutze hier den bestehenden Delete Code
        const metaHtml = `
            <div style="display:flex; align-items:center; justify-content:center; gap:10px;">
                <span>${msg.sender} ‚Ä¢ ${date} (${viewerIdx+1}/${viewerMsgs.length})</span>
                <button onclick="deleteMessage(${msg.ts})" style="background:rgba(255,255,255,0.2); border:1px solid #666; color:white; border-radius:4px; cursor:pointer; font-size:16px; padding:2px 8px;">üóëÔ∏è</button>
            </div>
        `;
        document.getElementById('viewerMeta').innerHTML = metaHtml;
    }

    function viewerNext(dir) {
        const next = viewerIdx + dir;
        if(next >= 0 && next < viewerMsgs.length) {
            viewerIdx = next;
            updateViewerUI();
        }
    }
 
    // --- DELETE LOGIC ---
    async function deleteMessage(ts) {
        if(!confirm("Nachricht wirklich l√∂schen?")) return;
        
        const btn = event.currentTarget;
        const originalIcon = btn.innerHTML;
        btn.innerHTML = "‚è≥"; 
        
        try {
            const url = `https://api.github.com/repos/${conf.gu}/${conf.gr}/contents/messages.json?t=${Date.now()}`;
            const header = { 'Authorization': `Bearer ${conf.gt}`, 'Accept': 'application/vnd.github.v3+json' };
            
            const resp = await fetch(url, { headers: header, cache: "no-store" });
            if(!resp.ok) throw new Error(`GitHub Load Error: ${resp.status}`);
            
            const fileData = await resp.json();
            let rawB64 = fileData.content; 
            if (!rawB64 && fileData.sha) {
                const blobUrl = `https://api.github.com/repos/${conf.gu}/${conf.gr}/git/blobs/${fileData.sha}`;
                const blobResp = await fetch(blobUrl, { headers: header, cache: "no-store" });
                if(blobResp.ok) {
                    const blobData = await blobResp.json();
                    rawB64 = blobData.content;
                }
            }
            if (!rawB64) throw new Error("Konnte Dateiinhalt nicht laden.");
            
            const cleanB64 = rawB64.replace(/\s/g, ''); 
            const content = JSON.parse(decodeURIComponent(escape(atob(cleanB64))));
            
            let foundIndex = content.findIndex(m => m.timestamp === ts);
            
            if(foundIndex !== -1) {
                content[foundIndex].hidden = true; 
            } else {
                const localMsg = viewerMsgs.find(m => m.ts === ts);
                if(localMsg) {
                    content.push({ timestamp: ts, enc: localMsg.enc, img: null, hidden: true });
                    content.sort((a,b) => a.timestamp - b.timestamp);
                }
            }

            const newContent = btoa(unescape(encodeURIComponent(JSON.stringify(content))));
            const putUrl = `https://api.github.com/repos/${conf.gu}/${conf.gr}/contents/messages.json`;
            const updateBody = {
                message: "Delete/Hide Message via App",
                content: newContent,
                sha: fileData.sha 
            };

            const putResp = await fetch(putUrl, {
                method: 'PUT',
                headers: { 'Authorization': `Bearer ${conf.gt}`, 'Content-Type': 'application/json' },
                body: JSON.stringify(updateBody)
            });

            if(!putResp.ok) throw new Error("GitHub Save Error");

            await fetch(`https://ntfy.sh/${conf.t}`, { 
                method: 'POST', 
                body: JSON.stringify({ cmd: 'DELETE', ts: ts }) 
            });

            // Lokal entfernen
            viewerMsgs = viewerMsgs.filter(m => m.ts !== ts);
            viewerHiddenSet.add(ts); // Auf die Blacklist setzen!
            updateViewerUI();
            alert("Gel√∂scht! üóëÔ∏è");

        } catch(e) { console.error(e); alert("Fehler: " + e.message); }
        if(btn) btn.innerHTML = originalIcon;
    }

   

    function viewerNext(dir) {
        const next = viewerIdx + dir;
        if(next >= 0 && next < viewerMsgs.length) {
            viewerIdx = next;
            updateViewerUI(); // FIX: Hier stand vorher updateViewer()
        }
    }


// ==========================================
    // === PWA & PUSH NOTIFICATIONS (Zusatz) ===
    // ==========================================

    // 1. Service Worker registrieren (sobald die Seite l√§dt)
    if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('sw.js')
        .then(reg => console.log("Service Worker bereit", reg))
        .catch(err => console.error("Service Worker Fehler", err));
    }

   // 2. Hilfsfunktion: VAPID Key Formatierung
    function urlBase64ToUint8Array(base64String) {
        const padding = '='.repeat((4 - base64String.length % 4) % 4);
        const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/');
        const rawData = window.atob(base64);
        const outputArray = new Uint8Array(rawData.length);
        for (let i = 0; i < rawData.length; ++i) {
            outputArray[i] = rawData.charCodeAt(i);
        }
        return outputArray;
    }

// === 3. PUSH AKTIVIEREN (Finaler Key) ===
    async function enablePush() {
        console.log("Starte Push-Setup...");
        
        // Das ist der OFFIZIELLE ntfy.sh Key (Hardcoded)
        const PUBLIC_VAPID_KEY = "BCrW4iR6nI5D6l-BvG5n7yq0s_I9J4y8p8q8P8s8t8u8v8w8x8y8z8A8B8C8D8E8F8G8H8I8J8K8L8M8N8O8P";

        if(!conf.t) return alert("Bitte erst Kanal Name in den Einstellungen speichern!");
        
        const btn = document.querySelector('#pushRow button'); 
        if(btn) btn.innerText = "‚è≥";

        try {
            // A. Berechtigung im Browser abfragen
            const permission = await Notification.requestPermission();
            if (permission !== 'granted') throw new Error("Benachrichtigungen wurden verweigert.");

            // B. Service Worker pr√ºfen
            if(!navigator.serviceWorker) throw new Error("Service Worker nicht unterst√ºtzt.");
            const reg = await navigator.serviceWorker.ready;

            // C. Abonnieren
            // Wir nutzen die Hilfsfunktion unten, um die Sonderzeichen im Key zu reparieren
            const convertedKey = urlBase64ToUint8Array(PUBLIC_VAPID_KEY);
            
            const sub = await reg.pushManager.subscribe({
                userVisibleOnly: true,
                applicationServerKey: convertedKey
            });

            // D. Abo an ntfy senden
            await fetch(`https://ntfy.sh/${conf.t}/push`, {
                method: 'POST',
                body: JSON.stringify(sub)
            });

            alert("Push aktiv! üîî\n\nSchlie√üe die App und sende eine Testnachricht.");
            if(btn) { btn.innerText = "Aktiv ‚úÖ"; btn.disabled = true; }

        } catch (e) {
            console.error(e);
            alert("Fehler: " + e.message);
            if(btn) btn.innerText = "Fehler ‚ùå";
        }
    }

    // === WICHTIG: Hilfsfunktion f√ºr den Key ===
    // Diese Funktion repariert den 'atob' Fehler bei Sonderzeichen
    function urlBase64ToUint8Array(base64String) {
        const padding = '='.repeat((4 - base64String.length % 4) % 4);
        const base64 = (base64String + padding)
            .replace(/-/g, '+') // Wandelt - in + um
            .replace(/_/g, '/'); // Wandelt _ in / um
        
        const rawData = window.atob(base64);
        const outputArray = new Uint8Array(rawData.length);
        
        for (let i = 0; i < rawData.length; ++i) {
            outputArray[i] = rawData.charCodeAt(i);
        }
        return outputArray;
    }

    // === 6. LOG VIEW LOGIC ===
    async function loadLogData() {
        const list = document.getElementById('logList');
        const status = document.getElementById('logStatus');
        
        status.innerText = "Lade GitHub...";
        list.innerHTML = '<div class="log-empty">‚è≥ Lade Daten...</div>';
        
        if(!conf.gu || !conf.gr || !conf.gt) {
            list.innerHTML = '<div class="log-empty">‚ùå GitHub Config fehlt</div>';
            return;
        }

        try {
            // Wir laden logs.json
            const url = `https://api.github.com/repos/${conf.gu}/${conf.gr}/contents/logs.json?t=${Date.now()}`;
            const header = { 'Authorization': `Bearer ${conf.gt}`, 'Accept': 'application/vnd.github.v3+json' };
            
            const resp = await fetch(url, { headers: header, cache: "no-store" });
            if(resp.status === 404) {
                list.innerHTML = '<div class="log-empty">üì≠ Noch keine Logs vorhanden.</div>';
                status.innerText = "Leer";
                return;
            }
            
            const fileData = await resp.json();
            
            // Content Decode Logic (identisch zu messages)
            let rawB64 = fileData.content;
            if (!rawB64 && fileData.sha) {
                 const blobResp = await fetch(`https://api.github.com/repos/${conf.gu}/${conf.gr}/git/blobs/${fileData.sha}`, { headers: header });
                 if(blobResp.ok) {
                     const blobData = await blobResp.json();
                     rawB64 = blobData.content;
                 }
            }
            if(!rawB64) throw new Error("Kein Inhalt");
            
            const cleanB64 = rawB64.replace(/\s/g, '');
            const logArray = JSON.parse(decodeURIComponent(escape(atob(cleanB64))));
            
            // UI leeren und neu bef√ºllen
            list.innerHTML = "";
            let count = 0;

            // Neueste zuerst (Reverse Loop oder Sort)
            logArray.sort((a,b) => b.timestamp - a.timestamp);

            for(let item of logArray) {
                // Entschl√ºsseln
                try {
                    const jsonStr = await decryptText(item.enc, conf.p);
                    if(!jsonStr) continue; // Skip bei falschem Passwort
                    
                    const log = JSON.parse(jsonStr);
                    // log Format: { type: "read", ts: 12345, dev: "Oma", sender: "Max", snippet: "Hallo..." }
                    
                    renderLogItem(list, log, item.timestamp);
                    count++;
                } catch(e) { console.warn("Log Decrypt Fail", e); }
            }

            if(count === 0) list.innerHTML = '<div class="log-empty">üì≠ Keine lesbaren Logs.</div>';
            status.innerText = `Stand: ${new Date().toLocaleTimeString()}`;

        } catch(e) {
            console.error(e);
            list.innerHTML = `<div class="log-empty">‚ùå Fehler: ${e.message}</div>`;
        }
    }

    function renderLogItem(container, data, serverTs) {
        // Zeit formatieren
        const dateObj = new Date(data.ts * 1000);
        const day = dateObj.toLocaleDateString([], {day:'2-digit', month:'2-digit'});
        const time = dateObj.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
        
        // Icon basierend auf Device ID (Visual Candy)
        let icon = "üì±";
        if(data.dev && data.dev.toLowerCase().includes("pc")) icon = "üíª";
        if(data.dev && data.dev.toLowerCase().includes("tablet")) icon = "üìü";

        const html = `
            <div class="log-item">
                <div class="log-icon">${icon}</div>
                <div class="log-content">
                    <div class="log-title">
                        <span>${data.dev || "Unbekannt"}</span>
                        <span class="log-badge">Gelesen</span>
                    </div>
                    <div class="log-meta">
                        <span>üïí ${day} um ${time}</span>
                    </div>
                    ${data.snippet ? `<div class="log-snippet">"${data.snippet}..." <br><span style="font-size:10px; opacity:0.7">von ${data.sender||'?'}</span></div>` : ''}
                </div>
            </div>
        `;
        container.insertAdjacentHTML('beforeend', html);
    }

// === ONBOARDING TOUR LOGIC ===
    const tour = {
        steps: [
            {
                sel: '#senderName',
                title: 'üë§ Wer bist du?',
                text: 'Gib hier deinen Namen ein (z.B. "Papa" oder "Lisa"). So wei√ü Oma sofort, von wem die Nachricht kommt.'
            },
            {
                sel: '#msgText',
                title: '‚úâÔ∏è Deine Nachricht',
                text: 'Hier schreibst du deinen Text. Einfach tippen ‚Äì Formatierungen sind nicht n√∂tig.'
            },
            {
                sel: '.media-upload',
                title: 'üì∑ Fotos & Sicherheit',
                text: 'Du kannst Bilder direkt vom Handy hochladen. Wichtig: Text & Bilder werden mit AES-256 (Milit√§r-Standard) verschl√ºsselt. Niemand au√üer euch kann sie sehen!'
            },
            {
                sel: '#btnSend',
                title: 'üöÄ Ab die Post',
                text: 'Ein Klick sendet alles sicher verschl√ºsselt an Oma.'
            },
            {
                sel: '.btn-icon[onclick="toggleSidebar(true)"]', 
                title: 'üçî Das Men√º',
                text: 'Hier oben findest du weitere Funktionen.',
                action: () => toggleSidebar(false) // Sicherstellen, dass zu ist
            },
            {
                sel: '.menu-item[onclick="switchTab(\'view\')"]',
                title: 'üëÅÔ∏è Verlauf & Kontrolle',
                text: 'Hier siehst du genau das, was auch Oma sieht. Du kannst Nachrichten pr√ºfen und bei Bedarf sogar wieder l√∂schen (M√ºlleimer-Icon).',
                action: () => toggleSidebar(true) // Men√º √∂ffnen f√ºr diesen Schritt
            }
        ],
        idx: -1,
        
        init: function() {
            if (!localStorage.getItem('tour_done_v1')) {
                // Kurze Verz√∂gerung beim ersten Start
                setTimeout(() => this.start(), 1000);
            }
        },

        start: function() {
            this.idx = 0;
            document.getElementById('tour-layer').style.display = 'block';
            this.render();
        },

        render: function() {
            const step = this.steps[this.idx];
            
            // 1. Action ausf√ºhren (z.B. Sidebar √∂ffnen/schlie√üen)
            if(step.action) step.action();

            // 2. Element finden
            // Kurzes Timeout, damit die Animation (z.B. Sidebar) fertig ist, bevor wir messen
            setTimeout(() => {
                const el = document.querySelector(step.sel);
                if(!el) return this.end(); // Fallback

                const rect = el.getBoundingClientRect();
                const spot = document.getElementById('tour-spotlight');
                const card = document.getElementById('tour-card');

                // Spotlight positionieren
                spot.style.width = rect.width + 10 + 'px';
                spot.style.height = rect.height + 10 + 'px';
                spot.style.top = (rect.top - 5) + 'px';
                spot.style.left = (rect.left - 5) + 'px';

                // Texte setzen
                document.getElementById('tourTitle').innerText = step.title;
                document.getElementById('tourText').innerText = step.text;
                
                // Buttons
                const nextBtn = document.getElementById('tourNextBtn');
                if(this.idx === this.steps.length - 1) {
                    nextBtn.innerText = "Fertig üéâ";
                    nextBtn.onclick = () => this.end();
                } else {
                    nextBtn.innerText = this.idx === 0 ? "Weiter" : "Weiter ‚ùØ";
                    nextBtn.onclick = () => this.next();
                }

                // Karte positionieren (Automatisch oben oder unten)
                // Standard: Unter dem Element
                let cardTop = rect.bottom + 20;
                // Wenn zu weit unten (au√üerhalb viewport), dann dar√ºber platzieren
                if (cardTop + 200 > window.innerHeight) {
                    cardTop = rect.top - 220; // Ca H√∂he der Karte abziehen
                }
                
                card.style.top = cardTop + 'px';
                // Horizontal zentrieren, aber im Rahmen bleiben
                let cardLeft = (window.innerWidth / 2) - (card.offsetWidth / 2);
                card.style.left = cardLeft + 'px';

                // Dots updaten
                const dots = document.getElementById('tourDots');
                dots.innerHTML = '';
                this.steps.forEach((_, i) => {
                    dots.innerHTML += `<div class="tour-dot ${i === this.idx ? 'active' : ''}"></div>`;
                });

            }, 350); // Wartezeit f√ºr CSS Transitions (Sidebar)
        },

        next: function() {
            this.idx++;
            if (this.idx >= this.steps.length) {
                this.end();
            } else {
                this.render();
            }
        },

        end: function() {
            localStorage.setItem('tour_done_v1', 'true');
            document.getElementById('tour-layer').style.display = 'none';
            toggleSidebar(false); // Aufr√§umen
        }
    };


// --- QR CODE FIX ---
    let html5QrCode = null;

    function toggleQrModal(open) {
        document.getElementById('qrModal').classList.toggle('active', open);
        
        if(open) {
            showQrTab('gen');
        } else {
            // Beim Schlie√üen sicher stoppen
            if(html5QrCode && html5QrCode.isScanning) {
                html5QrCode.stop().then(() => {
                    html5QrCode.clear();
                }).catch(err => console.log("Stop Error", err));
            }
        }
    }

    function showQrTab(tab) {
        document.getElementById('qrGenView').style.display = tab === 'gen' ? 'flex' : 'none';
        document.getElementById('qrScanView').style.display = tab === 'scan' ? 'flex' : 'none';
        
        if(tab === 'gen') {
            document.getElementById('qrCodeDiv').innerHTML = "";
            // JSON stringify der config
            const jsonConf = JSON.stringify(conf);
            // Wir nutzen window.location.href um die volle URL inkl. https:// zu bekommen
            // split('#')[0] entfernt alte Hash-Reste
            const cleanUrl = window.location.href.split('#')[0];
            const payload = cleanUrl + "#config=" + btoa(jsonConf);
            
            new QRCode(document.getElementById("qrCodeDiv"), {
                text: payload,
                width: 200, height: 200,
                correctLevel : QRCode.CorrectLevel.L
            });
        } else {
            // Kurze Pause, damit das DOM (CSS display:flex) fertig gerendert ist
            setTimeout(startScanner, 300);
        }
    }

function startScanner() {
        // Erstmal aufr√§umen, falls was l√§uft
        if(html5QrCode) {
            try { html5QrCode.clear(); } catch(e){}
        }

        html5QrCode = new Html5Qrcode("qrReader");
        
        const statusEl = document.getElementById('scanStatus');
        statusEl.innerText = "Starte Kamera...";
        statusEl.style.color = "var(--text-sub)";

        // Simpler Config ohne Box-Zwang
        const config = { 
            fps: 10, 
            aspectRatio: 1.0 
        };

        html5QrCode.start(
            { facingMode: "environment" }, 
            config,
            (decodedText, decodedResult) => {
                // SUCCESS
                if(decodedText.includes("config=")) {
                    html5QrCode.stop().then(() => {
                        console.log("Scan:", decodedText);
                        
                        // Hash isolieren
                        const parts = decodedText.split('#');
                        const hashPart = parts.length > 1 ? '#' + parts[parts.length - 1] : decodedText;
                        const finalHash = hashPart.startsWith('#') ? hashPart : '#' + hashPart;

                        // Anwenden
                        window.location.hash = finalHash;
                        window.location.reload();
                    }).catch(e => console.error(e));
                }
            },
            (errorMessage) => {
                // Parsing Fehler ignorieren wir (passiert bei jedem Frame ohne QR)
            }
        ).catch(err => {
            console.error("Camera Error:", err);
            // Fallback Nachricht f√ºr den User
            statusEl.innerHTML = `
                <div style="color:var(--danger); font-weight:bold">Kamera konnte nicht starten.</div>
                <div style="margin-top:10px; font-size:12px">
                    Bitte nutze deine normale Kamera-App und scanne den Code vom anderen Handy ab.<br>
                    <br>Fehler: ${err}
                </div>
            `;
        });
    }
  
    
    // Tour initialisieren (ganz am Ende starten)
    tour.init();
    
</script>
</body>
</html>
